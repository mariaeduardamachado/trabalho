<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Gráfico de Comparação</title>
  <!-- Importar Chart.js através de CDN -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    .chart-container {
      display: flex;
      justify-content: space-around;
      flex-wrap: wrap;
    }
    canvas {
      width: 45%;
      height: 300px;
    }
  </style>
</head>
<body>

  <div class="chart-container">
    <div>
      <h2>Gráfico para Vetor Aleatório</h2>
      <canvas id="randomChart"></canvas>
    </div>

    <div>
      <h2>Gráfico para Vetor Ordenado</h2>
      <canvas id="sortedChart"></canvas>
    </div>

    <div>
      <h2>Gráfico para Vetor Decrescente</h2>
      <canvas id="reverseChart"></canvas>
    </div>

    <div>
      <h2>Gráfico Comparando Todos</h2>
      <canvas id="combinedChart"></canvas>
    </div>
  </div>

  <script>
    // Função para gerar vetor de n números aleatórios
    function getVetorAleatorio(n) {
      let vetor = [];
      for (let i = 0; i < n; i++) {
        vetor.push(Math.round(Math.random() * 1000000));
      }
      return vetor;
    }

    // Função para gerar vetor ordenado de n números
    function getVetorOrdenado(n) {
      let vetor = [];
      for (let i = 0; i < n; i++) {
        vetor.push(i);
      }
      return vetor;
    }

    // Função para gerar vetor decrescente de n números
    function getVetorDecrescente(n) {
      let vetor = [];
      for (let i = n; i > 0; i--) {
        vetor.push(i);
      }
      return vetor;
    }

    // Algoritmos de ordenação
    function bubbleSort(arr) {
      let n = arr.length;
      for (let i = 0; i < n - 1; i++) {
        for (let j = 0; j < n - i - 1; j++) {
          if (arr[j] > arr[j + 1]) {
            [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
          }
        }
      }
      return arr;
    }

    function bubbleSortOptimized(arr) {
      let swapped;
      do {
        swapped = false;
        for (let i = 0; i < arr.length - 1; i++) {
          if (arr[i] > arr[i + 1]) {
            [arr[i], arr[i + 1]] = [arr[i + 1], arr[i]];
            swapped = true;
          }
        }
      } while (swapped);
      return arr;
    }

    // Função para medir tempo de execução
    function measureTime(sortFunction, arr) {
      let startTime = performance.now();
      sortFunction(arr.slice());
      let endTime = performance.now();
      return endTime - startTime;
    }

    // Função para gerar o gráfico
    function plotGraph(chartId, labels, data) {
      const ctx = document.getElementById(chartId).getContext('2d');
      new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: data
        },
        options: {
          scales: {
            x: {
              title: { display: true, text: 'n (tamanho do vetor)' }
            },
            y: {
              title: { display: true, text: 'Tempo (ms)' }
            }
          }
        }
      });
    }

    // Função para realizar os testes e gerar os dados do gráfico
    function testSortingAlgorithms() {
      const sizes = [1000, 5000, 10000, 15000, 20000, 25000, 30000, 35000, 40000, 45000, 50000]; // Tamanhos dos vetores para teste

      const bubbleSortTimesRandom = [];
      const bubbleSortTimesSorted = [];
      const bubbleSortTimesReverse = [];
      const bubbleSortOptimizedTimes = [];

      sizes.forEach(size => {
        const vetorAleatorio = getVetorAleatorio(size);
        const vetorOrdenado = getVetorOrdenado(size);
        const vetorDecrescente = getVetorDecrescente(size);

        // Medir tempo de execução para vetor aleatório
        bubbleSortTimesRandom.push(measureTime(bubbleSort, vetorAleatorio));
        bubbleSortOptimizedTimes.push(measureTime(bubbleSortOptimized, vetorAleatorio));

        // Medir tempo de execução para vetor ordenado
        bubbleSortTimesSorted.push(measureTime(bubbleSort, vetorOrdenado));
        bubbleSortOptimizedTimes.push(measureTime(bubbleSortOptimized, vetorOrdenado));

        // Medir tempo de execução para vetor decrescente
        bubbleSortTimesReverse.push(measureTime(bubbleSort, vetorDecrescente));
        bubbleSortOptimizedTimes.push(measureTime(bubbleSortOptimized, vetorDecrescente));
      });

      // Plotar gráficos para cada cenário
      const datasets = [
        { label: 'Bubble Sort - Aleatório', data: bubbleSortTimesRandom, borderColor: 'rgba(255, 99, 132, 1)', fill: false },
        { label: 'Bubble Sort - Ordenado', data: bubbleSortTimesSorted, borderColor: 'rgba(54, 162, 235, 1)', fill: false },
        { label: 'Bubble Sort - Decrescente', data: bubbleSortTimesReverse, borderColor: 'rgba(255, 205, 86, 1)', fill: false },
        { label: 'Bubble Sort Optimizado', data: bubbleSortOptimizedTimes, borderColor: 'rgba(75, 192, 192, 1)', fill: false }
      ];

      plotGraph('randomChart', sizes, datasets);
      plotGraph('sortedChart', sizes, datasets);
      plotGraph('reverseChart', sizes, datasets);

      // Plotar gráfico combinado
      plotGraph('combinedChart', sizes, datasets);
    }

    // Executar os testes ao carregar a página
    window.onload = testSortingAlgorithms;
  </script>

</body>
</html>
